---
title: Table Component
description: A customizable table component for combining Markdown tables
slug: /internal/tables
unlisted: true
---

import Tables from '@site/src/components/Tables/index';
import BaseParams from './_partials/base-params.mdx';
import AdditionalParams from './_partials/additional-params.mdx';

# Tables Component

The Tables component provides a way to combine multiple Markdown tables into a single table. This allows you to reuse and extend table content across your documentation.

## Basic Usage

To combine Markdown tables, wrap them with the `<Tables>` component:

```jsx
<Tables caption="API Parameters">
| Name | Type | Default | Description |
|------|------|---------|-------------|
| text | string | - | The instructions to send to the agent |
| contexts | object | - | An object that defines the contexts for the AI |
</Tables>
```

## Component Properties

<Tables>

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| children | ReactNode | - | Table content (Markdown tables) |
| className | string | - | Additional CSS class name |
| caption | string | - | Adds a caption to the table |
| padPlaceholder | ReactNode | - | Placeholder for padded cells |
</Tables>

## How It Works

The Table component:

1. Takes any number of Markdown tables as children
2. Extracts the headers from the first table
3. Combines all table rows from all tables
4. Preserves Docusaurus default styling

This allows you to:
- Create reusable partial table definitions
- Extend tables with additional rows in other files

## Combining Tables

You can combine multiple tables by placing them inside a `<Tables>` component:

<Tables caption="Combined Tables Example">

| Name | Type | Default | Description |
|------|------|---------|-------------|
| text | string | - | The instructions to send to the agent |
| contexts | object | - | An object that defines the contexts for the AI |

| temperature | number | 1.0 | Controls how random the output gets |
| top_p | number | 1.0 | Alternative method to control randomness |

</Tables>

## Header Handling

When combining multiple tables, only the headers from the first table are used. Headers from subsequent tables are ignored, but their rows are still included:

<Tables caption="Headers From First Table Only">

{/* First table's headers are used */}
| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| text | string | - | The instructions to send to the agent |

{/* These headers are ignored, only rows are used */}
| Name | Data Type | Value | Notes |
|------|-----------|-------|-------|
| temperature | number | 1.0 | Controls randomness |

</Tables>

## Column Count Considerations

When combining tables with different column counts:
- Tables with fewer columns than the headers will have blank cells for missing columns
- Tables with more columns than the headers will have excess columns truncated

<Table caption="Handling Different Column Counts">

{/* First table defines 4 columns */}
| Name | Type | Default | Description |
|------|------|---------|-------------|
| text | string | - | The instructions to send to the agent |

| Name | Type | Default | Description | Thing |
|------|------|---------|-------------|-------|
| confidence | number | 0.6 | Threshold for events | (This won't show) |

{/* Second table has 3 columns - the 4th column will be empty */}
| Name | Type | Default |
|------|------|---------|
| temperature | number | 1.0 |
| top_p | number | 1.0 |



</Table>

## Using Partials

One of the most powerful features is the ability to create reusable table fragments in separate MDX files and combine them:

<Table caption="Combined from Partial Files" debug>

{/* Import a partial with headers - base-params.mdx */}
{BaseParams()}

{/* Import a partial with additional rows - additional-params.mdx */}
{AdditionalParams()}




</Table>

### How Partials Work

1. Create separate MDX files containing table fragments
2. Import them in your main document
3. Include them within a `<Table>` component
4. The component combines them into a single table

For the example above, we're importing these files:

- `_partials/base-params.mdx` (contains headers + initial rows)
- `_partials/additional-params.mdx` (contains temperature params)  
- `_partials/extra-rows.mdx` (contains additional param rows)

And then adding one more row directly in our document.

## Example MDX Structure

Create partial table files with standard Markdown syntax:

### _partials/base-params.mdx
```mdx
| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| text | string | - | The instructions to send to the agent |
| contexts | object | - | An object that defines the contexts for the AI |
```

### _partials/extra-params.mdx
```mdx
| temperature | number | 1.0 | Controls randomness |
| top_p | number | 1.0 | Alternative to temperature |
```

Then import and use them in your documentation:

```jsx
import Table from '@site/src/components/Table';
import BaseParams from './_partials/base-params.mdx';
import ExtraParams from './_partials/extra-params.mdx';

<Tables caption="API Parameters">
  <BaseParams />
  <ExtraParams />
  
  {/* Add more rows inline */}
  | confidence | number | 0.6 | Threshold for events |
</Tables>
```

## Best Practices

1. **Use consistent column structure** across all tables to ensure data aligns correctly
2. **Put the most descriptive headers first** if you have multiple tables
3. **Use placeholder values** like `-` or `N/A` for missing data
4. **Keep common parameters in reusable files** to maintain DRY principles
5. **When combining tables, ensure they follow the same semantic structure** even if the headers differ

## Common Pitfalls

1. **Inconsistent column structure** - Ensure all tables follow the same column structure
2. **Missing headers in first table** - Always include headers in the first table
3. **HTML in Markdown tables** - Be careful with HTML in Markdown tables; it may not process correctly
4. **Unequal column widths** - Column widths are determined by content; consider using consistent content

## Benefits of This Approach

This approach allows you to:

1. **Modularize your documentation** - Keep common parameters in their own files
2. **Reuse parameter definitions** - Reference the same parameter definitions across multiple pages
3. **Maintain consistency** - Update a parameter once and have it reflected everywhere
4. **Create custom groupings** - Combine parameters in different ways for different contexts
