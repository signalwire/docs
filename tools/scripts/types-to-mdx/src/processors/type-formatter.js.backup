export class TypeFormatter {
  constructor(logger) {
    this.logger = logger;
    this.allTypeNames = new Set();
  }

  setTypeNames(typeNames) {
    this.allTypeNames = typeNames;
  }

  formatType(type) {
    if (!type) return "unknown";

    try {
      return this.formatTypeInternal(type);
    } catch (error) {
      this.logger.warn(`Error formatting type: ${error.message}`);
      return "unknown";
    }
  }

  formatTypeInternal(type) {
    if (typeof type === "string") {
      return this.linkifyType(type);
    }

    if (type.type === "intrinsic") {
      return this.linkifyType(type.name);
    }

    if (type.type === "reference") {
      let result = this.linkifyType(type.name);

      if (type.typeArguments && type.typeArguments.length > 0) {
        const args = type.typeArguments
          .map((arg) => this.formatTypeInternal(arg))
          .join(", ");
        result += `<${args}>`;
      }

      return result;
    }

    if (type.type === "array") {
      return `${this.formatTypeInternal(type.elementType)}[]`;
    }

    if (type.type === "union") {
      const types = type.types.map((t) => this.formatTypeInternal(t));

      if (types.length > 3 || types.join(" | ").length > 60) {
        return types.join(" |\n  ");
      }

      return types.join(" | ");
    }

    if (type.type === "intersection") {
      const types = type.types.map((t) => this.formatTypeInternal(t));
      return types.join(" & ");
    }

    if (type.type === "literal") {
      if (typeof type.value === "string") {
        return `"${type.value}"`;
      }
      return `${type.value}`;
    }

    if (type.type === "reflection") {
      return this.formatReflectionType(type);
    }

    if (type.type === "tuple") {
      const elements = type.elements.map((el) => this.formatTypeInternal(el));
      return `[${elements.join(", ")}]`;
    }

    if (type.type === "conditional") {
      const checkType = this.formatTypeInternal(type.checkType);
      const extendsType = this.formatTypeInternal(type.extendsType);
      const trueType = this.formatTypeInternal(type.trueType);
      const falseType = this.formatTypeInternal(type.falseType);
      return `${checkType} extends ${extendsType} ? ${trueType} : ${falseType}`;
    }

    if (type.type === "mapped") {
      return this.formatMappedType(type);
    }

    if (type.type === "templateLiteral") {
      return this.formatTemplateLiteral(type);
    }

    return this.linkifyType(type.toString?.() || "unknown");
  }

  formatReflectionType(type) {
    if (type.declaration && type.declaration.signatures) {
      const signature = type.declaration.signatures[0];
      return this.formatMethodSignature(signature);
    }

    if (type.declaration && type.declaration.children) {
      const properties = type.declaration.children
        .map((child) => {
          const propType = this.formatTypeInternal(child.type);
          const optional = child.flags?.isOptional ? "?" : "";
          return `${child.name}${optional}: ${propType}`;
        })
        .join("; ");

      return `{ ${properties} }`;
    }

    return "object";
  }

  formatMappedType(type) {
    const parameter = type.parameter || "K";
    const parameterConstraint = type.parameterConstraint
      ? ` in ${this.formatTypeInternal(type.parameterConstraint)}`
      : "";
    const nameType = type.nameType ? ` as ${this.formatTypeInternal(type.nameType)}` : "";
    const templateType = this.formatTypeInternal(type.templateType);
    const optional = type.readonlyModifier ? "readonly " : "";
    const questionToken = type.optionalModifier ? "?" : "";

    return `{ ${optional}[${parameter}${parameterConstraint}]${nameType}${questionToken}: ${templateType} }`;
  }

  formatTemplateLiteral(type) {
    if (!type.head || !type.tail) return "string";

    let result = "`" + type.head;

    type.tail.forEach(([templateType, literal]) => {
      result += "${" + this.formatTypeInternal(templateType) + "}" + literal;
    });

    result += "`";
    return result;
  }

  formatMethodSignature(signature) {
    if (!signature) return "Method";

    let result = "(";

    if (signature.parameters && signature.parameters.length > 0) {
      const params = signature.parameters.map((param) => {
        let paramStr = param.name;
        if (param.flags?.isOptional || param.defaultValue !== undefined) {
          paramStr += "?";
        }
        if (param.type) {
          paramStr += ": " + this.formatTypeInternal(param.type);
        }
        return paramStr;
      });
      result += params.join(", ");
    }

    result += ")";

    if (signature.type) {
      result += " => " + this.formatTypeInternal(signature.type);
    }

    return result;
  }

  linkifyType(typeString) {
    if (!typeString || !this.allTypeNames.size) return typeString;

    const typeNamesArray = Array.from(this.allTypeNames);
    const regex = new RegExp(
      `\\b(${typeNamesArray.map(this.escapeRegex).join("|")})\\b`,
      "g",
    );

    return typeString.replace(regex, (match) => {
      if (this.allTypeNames.has(match)) {
        const anchor = match.toLowerCase().replace(/[^a-z0-9]/g, "-");
        return `[${match}](#${anchor})`;
      }
      return match;
    });
  }

  escapeRegex(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
}
