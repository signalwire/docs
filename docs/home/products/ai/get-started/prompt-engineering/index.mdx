---
title: Prompt Engineering Best Practices
slug: /ai/get-started/prompt-engineering
description: Learn essential prompt engineering techniques and best practices for crafting effective interactions with SignalWire AI Agents.
---


# Prompt Engineering Best Practices

<Subtitle>Master the art of crafting effective prompts for SignalWire AI Agents</Subtitle>

## Introduction

Prompt engineering is the art and science of crafting clear, effective instructions for AI models. In the context of SignalWire AI Agents, it serves as the foundation for achieving consistent, high-quality interactions that precisely match your requirements. Well-crafted prompts act as a bridge between human intent and AI execution, enabling you to harness the full potential of AI capabilities while maintaining precise control over the output.

The effectiveness of an AI interaction largely depends on how well you communicate your requirements. Just as a new employee needs clear direction to perform at their best, AI models require well-structured, unambiguous instructions to deliver optimal results. This guide will walk you through proven techniques and best practices that will help you master the art of prompt engineering.

<Admonition type="tip">
Think of prompt engineering as writing instructions for a brilliant but very literal new employee. The more precise and contextual your instructions, the better the results. This mental model helps in crafting prompts that are both comprehensive and unambiguous.
</Admonition>

## Core Principles

### Clarity and Directness

The foundation of effective prompt engineering lies in clarity and directness. AI models, despite their sophistication, interpret instructions literally and lack the human ability to infer unstated requirements or fill in gaps with common sense. Therefore, explicit and detailed instructions are crucial for achieving desired outcomes.

When crafting prompts, focus on eliminating ambiguity and providing comprehensive context. Your instructions should leave no room for interpretation, clearly stating not just what you want the AI to do, but also how you want it done and what the expected outcome should look like.

Here are key elements that contribute to clear and direct prompts:

1. **Be Specific**
   Your instructions should precisely define both the task and its boundaries. Consider these aspects:
   - State exactly what you want the AI to do
   - Define the scope and boundaries of the task
   - Specify the desired format for the output

2. **Provide Context**
   Context helps the AI understand the broader purpose and align its responses accordingly:
   - Explain the purpose of the task
   - Describe the intended audience
   - Include relevant background information

3. **Set Clear Parameters**
   Define success criteria and constraints to ensure the output meets your requirements:
   - Define success criteria
   - Specify any constraints or limitations
   - Include quality requirements

<PreviewCardGroup columns={2}>
  <PreviewCard 
    title="❌ Unclear Prompt" 
    description="Write some product documentation."
  >
The vague instruction leaves too much room for interpretation and may not yield the desired results. Without specific parameters, the AI lacks the necessary context to generate appropriate content.
  </PreviewCard>
  <PreviewCard 
    title="✅ Clear Prompt" 
    description="Write technical documentation for our new API authentication feature. Include:
- Step-by-step setup instructions
- Code examples in Python and JavaScript
- Common error scenarios and solutions
- Security best practices
Target audience: Senior developers familiar with REST APIs."
  >
This prompt provides clear direction, specific requirements, and important context about the target audience, enabling the AI to generate more focused and useful content.
  </PreviewCard>
</PreviewCardGroup>

### Structure and Format

The way you structure your prompts significantly impacts their effectiveness. Well-organized prompts help the AI process information systematically and respond in a structured manner. SignalWire AI supports both Markdown and XML-style formatting, giving you flexibility in how you structure your prompts while maintaining clarity and organization.

When structuring your prompts, consider using either Markdown or XML tags based on your preference and use case. Both approaches offer clear ways to organize information and maintain consistency throughout your prompts.

<Tabs>
<TabItem value="markdown" label="Markdown Format">

```markdown
# Task Overview
Create a customer response template for common support queries.

## Context
Support team needs standardized responses for frequently asked questions.

## Requirements
- Maintain professional tone
- Include relevant documentation links
- Provide step-by-step instructions

## Constraints
- Keep responses under 200 words
- Use simple, clear language
```

</TabItem>
<TabItem value="xml" label="XML Format">

```xml
<context>
This is a customer support interaction for a technical product.
</context>

<task>
Analyze the customer's issue and provide a solution.
</task>

<constraints>
- Use technical but approachable language
- Include step-by-step troubleshooting steps
- Reference relevant documentation when needed
</constraints>
```

</TabItem>
</Tabs>

Both formatting styles serve the same purpose: organizing information in a clear, hierarchical structure. Choose the style that best fits your workflow and maintain consistency throughout your prompts. The key aspects of good prompt structure include:

1. **Clear Section Boundaries**
   Whether using Markdown headers or XML tags, clearly separate different components of your prompt to help the AI process information more effectively.

2. **Logical Flow**
   Organize information in a natural progression, from context and requirements to specific instructions and constraints.

3. **Consistent Formatting**
   Maintain uniform styling and organization throughout your prompts to ensure reliable, predictable responses.

## Advanced Techniques

As you become more comfortable with basic prompt engineering, you can leverage advanced techniques to achieve more sophisticated and nuanced interactions. These techniques help you handle complex scenarios and achieve more precise control over the AI's responses.

### Multishot Prompting

Multishot prompting, also known as example-based prompting, is a powerful technique where you provide multiple examples to guide the AI's behavior. By showing the AI several examples of desired input-output patterns, you create a clear template for it to follow.

Here's an example of multishot prompting:

```markdown
When responding to customer inquiries, follow these example patterns:

Input: "How do I reset my password?"
Response: 
1. Visit the login page
2. Click "Forgot Password"
3. Enter your email
4. Follow the reset link in your email
Note: Reset links expire in 24 hours.

Input: "Where can I find API documentation?"
Response:
1. Go to our documentation homepage
2. Navigate to "API Reference"
3. Select your preferred programming language
Note: Sample code is available for all major languages.
```

This technique is especially valuable when:
- Dealing with complex response formats
- Handling edge cases
- Ensuring consistency across multiple interactions
- Teaching the AI specific patterns or styles

### Chain of Thought

Chain of Thought prompting encourages the AI to break down complex tasks into smaller, logical steps and show its reasoning process. This approach not only helps the AI arrive at better solutions but also makes its decision-making process transparent and verifiable.

<Tabs>
<TabItem value="markdown" label="Markdown Format">

```markdown
# Technical Issue Analysis Process

## Analysis Steps
When analyzing technical issues, follow these steps:

1. Problem Statement
   - Clearly state the reported issue
   - List any error messages or symptoms
   - Note the context and environment

2. Information Gathering
   - Identify relevant system components
   - Check for recent changes
   - List affected functionalities

3. Analysis
   - Consider possible root causes
   - Evaluate impact and severity
   - Identify potential solutions

4. Solution
   - Choose the most appropriate fix
   - Explain the reasoning
   - List implementation steps
```

</TabItem>
<TabItem value="xml" label="XML Format">

```xml
<analysis>
  <problem>
    - Clearly state the reported issue
    - List any error messages or symptoms
    - Note the context and environment
  </problem>

  <information>
    - Identify relevant system components
    - Check for recent changes
    - List affected functionalities
  </information>

  <evaluation>
    - Consider possible root causes
    - Evaluate impact and severity
    - Identify potential solutions
  </evaluation>

  <resolution>
    - Choose the most appropriate fix
    - Explain the reasoning
    - List implementation steps
  </resolution>
</analysis>
```

</TabItem>
</Tabs>

This technique helps:
- Break down complex problems
- Ensure thorough analysis
- Document decision-making
- Maintain logical flow

---

### Progressive Refinement

Progressive refinement involves iteratively improving responses through increasingly specific instructions. Start with a broad request and gradually add constraints and requirements.

Example:

<Tabs>
<TabItem value="markdown" label="Markdown Format">

#### Initial Request
```markdown
## Task

Generate a product description.
```

#### Refinement 1
```markdown
## Task

Generate a product description for a technical audience, focusing on specifications and features.
```


#### Refinement 2
```markdown
## Task

Generate a product description for software engineers

## Requirements
- Technical specifications
- API integration details
- Performance metrics
- System requirements
```

#### Final Refinement
```markdown
## Task

Generate a product description for software engineers

## Steps
1. Starts with a technical overview
2. Lists detailed specifications
3. Provides API integration examples
4. Includes performance benchmarks
5. Specifies system requirements
```


</TabItem>
<TabItem value="xml" label="XML Format">

#### Initial Request
```xml
<task>
  Generate a product description.
</task>
```

#### Refinement 1
```xml
<task>
  Generate a product description for a technical audience, focusing on specifications and features.
</task>
```

#### Refinement 2
```xml
<task>Generate a product description for software engineers</task>

<requirements>
    - Technical specifications
    - API integration details
    - Performance metrics
    - System requirements
</requirements>
```

#### Final Refinement
```xml
<task>Generate a product description for software engineers</task>
<steps>
    1. Starts with a technical overview
    2. Lists detailed specifications
    3. Provides API integration examples
    4. Includes performance benchmarks
    5. Specifies system requirements
</steps>
<format>
    Use bullet points for specs, code blocks for examples
</format>
```
</TabItem>
</Tabs>

This approach helps:
- Fine-tune outputs
- Maintain clarity
- Build complexity gradually
- Achieve precise results

<Admonition type="tip">
These advanced techniques can be combined and adapted based on your specific needs. The key is understanding when and how to apply each technique effectively.
</Admonition>

## Best Practices for Different Tasks

Different types of tasks require different approaches to prompt engineering. Understanding these variations helps you craft more effective prompts for specific use cases. Let's explore the best practices for common task types.

### Analysis Tasks

Analysis tasks require the AI to process structured input data—such as API responses, log files, or metrics—and derive meaningful insights through systematic examination. These tasks involve two distinct steps:

1. **Data Collection**: External function calls retrieve raw data (e.g., API responses, logs)
2. **Data Analysis**: The AI analyzes the structured data to generate insights and recommendations

When crafting prompts for analysis tasks, you need to provide clear parameters that guide the AI in examining information and drawing conclusions. The key is to define both the breadth and depth of the analysis while specifying exactly how results should be presented.

#### Understanding Function Calls and Analysis

Let's examine a practical example using weather data to understand how function calls and analysis work together:


```json
// This is the raw response from a weather API function call
{
  "location": "San Francisco, CA",
  "temperature": "18°C",
  "condition": "Sunny",
  "humidity": "65%",
  "wind_speed": "12 km/h",
  "timestamp": "2024-03-02T20:00:00Z",
  "hourly_forecast": [
    {
      "time": "21:00:00Z",
      "temp": "17°C",
      "condition": "Clear"
    },
    {
      "time": "22:00:00Z",
      "temp": "16°C",
      "condition": "Clear"
    }
  ],
  "alerts": []
}
```

#### Structuring Analysis Input

After receiving the raw API response, we structure it appropriately for analysis. Here are examples in different formats:

<Tabs>
<TabItem value="json_format" label="JSON Format">

```json
{
  "analysis_metadata": {
    "data_source": "Weather API Response",
    "location": "San Francisco, CA",
    "analysis_timestamp": "2024-03-02T20:05:00Z"
  },
  "current_conditions": {
    "temperature": "18°C",
    "humidity": "65%",
    "wind_speed": "12 km/h",
    "overall_condition": "Sunny"
  },
  "forecast_summary": {
    "next_hours": [
      {
        "time": "21:00:00Z",
        "condition": "Clear",
        "temperature": "17°C"
      },
      {
        "time": "22:00:00Z",
        "condition": "Clear",
        "temperature": "16°C"
      }
    ]
  },
  "analysis_requirements": {
    "primary_focus": [
      "Current conditions evaluation",
      "Weather pattern identification",
      "Outdoor activity suitability",
      "Safety recommendations"
    ],
    "output_format": "Structured report with recommendations"
  }
}
```

</TabItem>
<TabItem value="yaml_format" label="YAML Format">

```yaml
analysis_metadata:
  data_source: "Weather API Response"
  location: "San Francisco, CA"
  analysis_timestamp: "2024-03-02T20:05:00Z"

current_conditions:
  temperature: "18°C"
  humidity: "65%"
  wind_speed: "12 km/h"
  overall_condition: "Sunny"

forecast_summary:
  next_hours:
    - time: "21:00:00Z"
      condition: "Clear"
      temperature: "17°C"
    - time: "22:00:00Z"
      condition: "Clear"
      temperature: "16°C"

analysis_requirements:
  primary_focus:
    - "Current conditions evaluation"
    - "Weather pattern identification"
    - "Outdoor activity suitability"
    - "Safety recommendations"
  output_format: "Structured report with recommendations"
```

</TabItem>
<TabItem value="xml_format" label="XML Format">

```xml
<weather_analysis>
  <metadata>
    <data_source>Weather API Response</data_source>
    <location>San Francisco, CA</location>
    <analysis_timestamp>2024-03-02T20:05:00Z</analysis_timestamp>
  </metadata>

  <current_conditions>
    <temperature>18°C</temperature>
    <humidity>65%</humidity>
    <wind_speed>12 km/h</wind_speed>
    <overall_condition>Sunny</overall_condition>
  </current_conditions>

  <forecast_summary>
    <hour>
      <time>21:00:00Z</time>
      <condition>Clear</condition>
      <temperature>17°C</temperature>
    </hour>
    <hour>
      <time>22:00:00Z</time>
      <condition>Clear</condition>
      <temperature>16°C</temperature>
    </hour>
  </forecast_summary>

  <analysis_requirements>
    <primary_focus>
      <focus>Current conditions evaluation</focus>
      <focus>Weather pattern identification</focus>
      <focus>Outdoor activity suitability</focus>
      <focus>Safety recommendations</focus>
    </primary_focus>
    <output_format>Structured report with recommendations</output_format>
  </analysis_requirements>
</weather_analysis>
```

</TabItem>
</Tabs>
#### Analysis Process

When designing analysis tasks, follow this workflow:

1. **Data Collection**
   - Identify required data sources
   - Make necessary function calls
   - Validate received data

2. **Data Structuring**
   - Convert raw responses to analysis format
   - Organize data hierarchically
   - Include all relevant context

3. **Analysis Configuration**
   - Define analysis objectives
   - Specify required insights
   - Set output format requirements

4. **Insight Generation**
   - Process structured data
   - Apply analysis criteria
   - Generate actionable insights
   - Format results as specified

<Admonition type="tip">
When working with API responses or other external data, always structure the input in a clear, organized format. This helps the AI understand the context and relationships within the data, leading to more accurate and useful analysis results.
</Admonition>

### Generation Tasks

Content generation tasks require a delicate balance between providing sufficient guidance and allowing the AI creative freedom where appropriate. The key to successful generation tasks lies in establishing clear boundaries while maintaining flexibility within those boundaries.

1. **Style Guidelines**
Define the tone and approach for generated content:
- Tone of voice (technical, casual, formal)
- Writing style (concise, detailed, conversational)
- Formatting requirements

2. **Quality Criteria**
Establish clear standards for the generated content:
- Accuracy requirements
- Completeness checks
- Consistency standards

### Conversation Design

Designing effective conversational interactions requires careful attention to flow and user experience. A well-designed conversation should feel natural while efficiently guiding users toward their goals. This involves planning for various interaction paths and potential user responses.

<Tabs>
<TabItem value="flow" label="Conversation Flow">

```xml
<conversation_flow>
- Greeting
- Problem identification
- Information gathering
- Solution proposal
- Confirmation
- Follow-up
</conversation_flow>
```

</TabItem>
<TabItem value="error" label="Error Handling">

```xml
<error_scenarios>
- Unclear user input: Ask for clarification
- Technical issues: Provide alternative solutions
- Out of scope: Redirect to appropriate resource
</error_scenarios>
```

</TabItem>
</Tabs>



## Quality Assurance

Quality assurance in prompt engineering is an iterative process that involves testing, monitoring, and refinement. A systematic approach to quality assurance helps ensure that your AI interactions consistently meet your requirements and provide value to users.

### Testing and Validation

Comprehensive testing is essential for ensuring prompt reliability and effectiveness. Your testing strategy should cover various scenarios and edge cases to verify that the AI responds appropriately across different situations.

1. **Edge Cases**
Test your prompts against challenging scenarios:
- Test with unexpected inputs
- Verify handling of extreme scenarios
- Check boundary conditions

2. **Performance Metrics**
Monitor key indicators of prompt effectiveness:
- Response accuracy
- Consistency across interactions
- Task completion rate

### Iteration Process

Prompt engineering is an iterative process that benefits from continuous refinement based on real-world performance and feedback. Regular evaluation and adjustment help optimize your prompts over time.

1. **Feedback Loop**
Establish a systematic process for improvement:
- Collect user feedback
- Monitor success rates
- Identify improvement areas

2. **Refinement**
Use collected data to enhance your prompts:
- Adjust prompt structure
- Enhance examples
- Update constraints

## Common Pitfalls to Avoid

Understanding common mistakes in prompt engineering can help you avoid them in your own implementations. Here are key pitfalls to watch out for, along with strategies to address them:

1. **Vague Instructions**
Ambiguous instructions lead to inconsistent results:
   - ❌ "Make it better"
   - ✅ "Improve code performance by reducing API call frequency"

2. **Inconsistent Formatting**
Maintaining consistency is crucial for reliable results:
   - ❌ Mixing different style conventions
   - ✅ Following a single, clear format throughout

3. **Missing Context**
Provide necessary background information:
   - ❌ Assuming background knowledge
   - ✅ Providing necessary context explicitly

4. **Overcomplicated Prompts**
Keep prompts focused and efficient:
   - ❌ Including unnecessary details
   - ✅ Keeping instructions focused and relevant

---

By following these best practices and continuously refining your approach, you'll be able to craft effective prompts that maximize the capabilities of SignalWire AI Agents. Remember that prompt engineering is an iterative process - don't hesitate to experiment and refine your prompts based on results and feedback.

## SignalWire Prompting Methods

SignalWire AI Agents use a sophisticated prompting system that combines global instructions with context-specific behaviors. Understanding these core concepts will help you create more effective and dynamic AI interactions.

### Global Instructions

Global instructions serve as the foundation for your AI Agent's behavior. These instructions persist throughout the entire conversation and define:
- Overall personality and tone
- Universal rules and guidelines
- Standard response patterns
- Basic interaction protocols

For example, a global instruction set might look like this:

<Tabs>
<TabItem value="markdown" label="Markdown Format">

```markdown
# Core Behavior Guidelines
You are a technical support specialist.

## General Approach
- Maintain professional yet friendly tone
- Use clear, precise language
- Show empathy and patience
- Follow security protocols

## Standard Process
1. Acknowledge the customer's concern
2. Ask clarifying questions when needed
3. Provide step-by-step solutions
4. Confirm understanding
```

</TabItem>
<TabItem value="xml" label="XML Format">

```xml
<behavior_guidelines>
  <role>
    You are a technical support specialist.
  </role>

  <general_approach>
    <guidelines>
      - Maintain professional yet friendly tone
      - Use clear, precise language
      - Show empathy and patience
      - Follow security protocols
    </guidelines>
  </general_approach>

  <standard_process>
    <steps>
      1. Acknowledge the customer's concern
      2. Ask clarifying questions when needed
      3. Provide step-by-step solutions
      4. Confirm understanding
    </steps>
  </standard_process>
</behavior_guidelines>
```

</TabItem>
</Tabs>

### Contexts and Steps

Contexts allow you to create specialized behavior patterns for different scenarios. Each context:
- Maintains its own conversation memory
- Has specific objectives and guidelines
- Can contain multiple sequential steps
- Operates independently of other contexts

Here's an example of how you might structure a technical support context:

<Tabs>
<TabItem value="markdown" label="Markdown Format">

```markdown
# Technical Support Context

## Problem Identification
First, gather essential information:
- Error messages or symptoms
- System configuration
- Recent changes or updates
- Impact and urgency

## Troubleshooting
Guide the user through resolution:
1. Start with basic diagnostics
2. Progress to specific solutions
3. Document each step attempted
4. Verify resolution success
```

</TabItem>
<TabItem value="xml" label="XML Format">

```xml
<technical_support>
  <problem_identification>
    <instructions>First, gather essential information:</instructions>
    <required_info>
      - Error messages or symptoms
      - System configuration
      - Recent changes or updates
      - Impact and urgency
    </required_info>
  </problem_identification>

  <troubleshooting>
    <instructions>Guide the user through resolution:</instructions>
    <steps>
      1. Start with basic diagnostics
      2. Progress to specific solutions
      3. Document each step attempted
      4. Verify resolution success
    </steps>
  </troubleshooting>
</technical_support>
```

</TabItem>
</Tabs>

### Context Switching

One of the powerful features of SignalWire AI Agents is their ability to switch contexts seamlessly. When a context switch occurs:
- Previous context memory is cleared
- New context's instructions take effect
- Global instructions remain active
- Conversation flow stays natural

This allows your AI Agent to:
- Handle different types of inquiries
- Maintain appropriate expertise per topic
- Keep conversations organized
- Provide specialized assistance as needed

### Memory Management

Understanding how memory works across contexts is crucial for effective prompt design:

1. **Global Memory**
   - Persists throughout the conversation
   - Maintains overall user context
   - Preserves important user information
   - Guides general behavior

2. **Context Memory**
   - Specific to each context
   - Resets on context switches
   - Maintains focused conversation flow
   - Prevents context pollution



### Best Practices for Prompting

1. **Clear Hierarchy**
   - Start with broad guidelines
   - Break down into specific instructions
   - Include examples where helpful
   - Maintain logical flow

2. **Context Design**
   - Create focused, single-purpose contexts
   - Define clear transition points
   - Include error handling guidelines
   - Maintain conversation coherence

3. **Memory Considerations**
   - Be mindful of context boundaries
   - Clear unnecessary information
   - Maintain relevant user details
   - Design for smooth transitions

