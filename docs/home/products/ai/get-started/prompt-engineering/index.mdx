---
title: Prompt engineering
slug: /ai/get-started/prompt-engineering
description: Learn essential prompt engineering techniques and best practices for crafting effective interactions with SignalWire AI Agents.
---


import Admonition from '@theme/Admonition';

# Prompt engineering best practices

<Subtitle>Master the art of crafting effective prompts for SignalWire AI Agents</Subtitle>

## Introduction

Prompt engineering is the art and science of crafting clear, effective instructions for AI models. In the context of SignalWire AI Agents, it serves as the foundation for achieving consistent, high-quality interactions that precisely match your requirements. Well-crafted prompts act as a bridge between human intent and AI execution, enabling you to harness the full potential of AI capabilities while maintaining precise control over the output.

The effectiveness of an AI interaction largely depends on how well you communicate your requirements. Just as a new employee needs clear direction to perform at their best, AI models require well-structured, unambiguous instructions to deliver optimal results. This guide will walk you through proven techniques and best practices that will help you master the art of prompt engineering.

:::tip
Think of prompt engineering as writing instructions for a brilliant but very literal new employee. The more precise and contextual your instructions, the better the results. This mental model helps in crafting prompts that are both comprehensive and unambiguous.
:::

## Core principles

### Clarity and directness

The foundation of effective prompt engineering lies in clarity and directness. AI models, despite their sophistication, interpret instructions literally and lack the human ability to infer unstated requirements or fill in gaps with common sense. Therefore, explicit and detailed instructions are crucial for achieving desired outcomes.

When crafting prompts, focus on eliminating ambiguity and providing comprehensive context. Your instructions should leave no room for interpretation, clearly stating not just what you want the AI to do, but also how you want it done and what the expected outcome should look like.

Here are key elements that contribute to clear and direct prompts:

1. **Be Specific**
   Your instructions should precisely define both the task and its boundaries. Consider these aspects:
   - State exactly what you want the AI to do
   - Define the scope and boundaries of the task
   - Specify the desired format for the output

2. **Provide Context**
   Context helps the AI understand the broader purpose and align its responses accordingly:
   - Explain the purpose of the task
   - Describe the intended audience
   - Include relevant background information

3. **Set Clear Parameters**
   Define success criteria and constraints to ensure the output meets your requirements:
   - Define success criteria
   - Specify any constraints or limitations
   - Include quality requirements

<PreviewCardGroup columns={2}>
  <PreviewCard
    expandable={false}
    title="❌ Unclear Prompt" 
    description="The vague instruction leaves too much room for interpretation and may not yield the desired results. Without specific parameters, the AI lacks the necessary context to generate appropriate content."
  >
```
Write some product documentation.
```
  </PreviewCard>
  <PreviewCard 
    expandable={false}
    title="✅ Clear Prompt" 
    description="This prompt provides clear direction, specific requirements, and important context about the target audience, enabling the AI to generate more focused and useful content."
  >
```
Write technical documentation for our 
new API authentication feature. Include:
- Step-by-step setup instructions
- Code examples in Python and JavaScript
- Common error scenarios and solutions
- Security best practices
Target audience: Senior developers 
familiar with REST APIs.
```
  </PreviewCard>
</PreviewCardGroup>

### Structure and format

The way you structure your prompts significantly impacts their effectiveness. Well-organized prompts help the AI process information systematically and respond in a structured manner. SignalWire AI supports both Markdown and XML-style formatting, giving you flexibility in how you structure your prompts while maintaining clarity and organization.

When structuring your prompts, consider using either Markdown or XML tags based on your preference and use case. Both approaches offer clear ways to organize information and maintain consistency throughout your prompts.

<Tabs>
<TabItem value="markdown" label="Markdown Format">

```markdown
# Task overview
Create a customer response template for common support queries.

## Context
Support team needs standardized responses for frequently asked questions.

## Requirements
- Maintain professional tone
- Include relevant documentation links
- Provide step-by-step instructions

## Constraints
- Keep responses under 200 words
- Use simple, clear language
```

</TabItem>
<TabItem value="xml" label="XML Format">

```xml
<context>
This is a customer support interaction for a technical product.
</context>

<task>
Analyze the customer's issue and provide a solution.
</task>

<constraints>
- Use technical but approachable language
- Include step-by-step troubleshooting steps
- Reference relevant documentation when needed
</constraints>
```

</TabItem>
</Tabs>

Both formatting styles serve the same purpose: organizing information in a clear, hierarchical structure. Choose the style that best fits your workflow and maintain consistency throughout your prompts. The key aspects of good prompt structure include:

1. **Clear Section Boundaries**
   Whether using Markdown headers or XML tags, clearly separate different components of your prompt to help the AI process information more effectively.

2. **Logical Flow**
   Organize information in a natural progression, from context and requirements to specific instructions and constraints.

3. **Consistent Formatting**
   Maintain uniform styling and organization throughout your prompts to ensure reliable, predictable responses.

## Advanced techniques

As you become more comfortable with basic prompt engineering, you can leverage advanced techniques to achieve more sophisticated and nuanced interactions. These techniques help you handle complex scenarios and achieve more precise control over the AI's responses.

### Multishot prompting

Multishot prompting, also known as example-based prompting, is a powerful technique where you provide multiple examples to guide the AI's behavior. By showing the AI several examples of desired input-output patterns, you create a clear template for it to follow.

Here's an example of multishot prompting:

```markdown
When responding to customer inquiries, follow these example patterns:

Input: "How do I reset my password?"
Response: 
1. Visit the login page
2. Click "Forgot Password"
3. Enter your email
4. Follow the reset link in your email
Note: Reset links expire in 24 hours.

Input: "Where can I find API documentation?"
Response:
1. Go to our documentation homepage
2. Navigate to "API Reference"
3. Select your preferred programming language
Note: Sample code is available for all major languages.
```

This technique is especially valuable when:
- Dealing with complex response formats
- Handling edge cases
- Ensuring consistency across multiple interactions
- Teaching the AI specific patterns or styles

### Chain of thought

Chain of thought prompting is a powerful technique that guides the AI through a structured reasoning process. By breaking down complex tasks into logical steps and explicitly showing the thought process, you can achieve more accurate and reliable results. This approach is particularly valuable when dealing with complex problem-solving tasks, technical troubleshooting, or situations requiring careful analysis.

### Purpose and benefits

Chain of thought prompting offers several key advantages:

1. **Enhanced Accuracy**
   - Reduces errors by following a systematic approach
   - Ensures all critical steps are considered
   - Maintains logical consistency throughout the process

2. **Improved Transparency**
   - Makes reasoning process visible and verifiable
   - Enables easier validation of outputs
   - Facilitates debugging when issues arise

3. **Better Context Management**
   - Maintains focus on relevant information
   - Prevents context loss during complex tasks
   - Enables proper handling of dependencies

### Implementation guide

Follow these steps to implement effective chain of thought prompting:

1. **Define the Goal**
   ```xml
   <task_definition>
     <primary_goal>Resolve customer authentication issue</primary_goal>
     <success_criteria>
       - User regains access
       - Security maintained
       - Process documented
     </success_criteria>
   </task_definition>
   ```

2. **Break Down the Process**
   ```xml
   <reasoning_steps>
     <step_1>
       <action>Identify the issue type</action>
       <considerations>
         - Login method used
         - Error messages
         - Recent changes
       </considerations>
     </step_1>
     <step_2>
       <action>Verify user identity</action>
       <considerations>
         - Authentication factors
         - Security protocols
         - Compliance requirements
       </considerations>
     </step_2>
     <step_3>
       <action>Implement solution</action>
       <considerations>
         - Security implications
         - User experience
         - Documentation needs
       </considerations>
     </step_3>
   </reasoning_steps>
   ```

3. **Validate Results**
   ```xml
   <validation_process>
     <check_points>
       - Verify each step completion
       - Confirm security compliance
       - Test solution effectiveness
     </check_points>
     <error_handling>
       - Identify failure points
       - Apply corrective actions
       - Document resolutions
     </error_handling>
   </validation_process>
   ```

### Practical examples

Let's examine two real-world applications of chain of thought prompting:

<Tabs>
<TabItem value="technical_troubleshooting" label="Technical Troubleshooting">

```xml
<troubleshooting_flow>
  <context>
    User reports API authentication failures after recent system update
  </context>

  <step_1>
    <action>Analyze Error Pattern</action>
    <process>
      - Review error logs
      - Identify error frequency
      - Note timing correlation
    </process>
    <output>
      Consistent 401 errors starting after update timestamp
    </output>
  </step_1>

  <step_2>
    <action>Verify Configuration</action>
    <process>
      - Check API credentials
      - Validate token format
      - Review permissions
    </process>
    <output>
      Token format changed in recent update
    </output>
  </step_2>

  <step_3>
    <action>Implement Fix</action>
    <process>
      - Update token format
      - Test authentication
      - Monitor success rate
    </process>
    <output>
      Authentication restored with new token format
    </output>
  </step_3>

  <validation>
    <checks>
      - Successful API calls
      - No security compromises
      - Documentation updated
    </checks>
  </validation>
</troubleshooting_flow>
```

</TabItem>
<TabItem value="content_creation" label="Content Creation">

```markdown
# Content Development Process

## Step 1: Define Objectives
- Target audience: Technical developers
- Content type: API documentation
- Key outcomes: Clear implementation guide

## Step 2: Research and Analysis
- Gather technical specifications
- Review existing documentation
- Identify common use cases

## Step 3: Content Structure
- Introduction and context
- Step-by-step implementation
- Code examples and validation
- Troubleshooting guide

## Step 4: Writing and Review
- Draft technical content
- Include practical examples
- Add error handling
- Review for accuracy

## Step 5: Validation
- Technical accuracy check
- Code sample testing
- User flow verification
- Documentation completeness
```

</TabItem>
</Tabs>

<Admonition type="tip">
When implementing chain of thought prompting, start with simpler tasks and gradually increase complexity. This helps you understand how the AI processes each step and allows you to refine your approach based on results.
</Admonition>

### Best practices for validation

1. **Intermediate Checkpoints**
   - Verify completion of each step
   - Validate assumptions
   - Check for logical consistency

2. **Error Detection**
   - Monitor for inconsistencies
   - Identify potential issues early
   - Document error patterns

3. **Quality Assurance**
   - Review final outputs
   - Test edge cases
   - Validate against requirements


## Progressive refinement

Progressive refinement is a systematic approach to improving prompt effectiveness through iterative enhancement. This technique involves starting with a basic prompt and gradually adding specificity, constraints, and requirements to achieve the desired output. The process helps maintain clarity while building complexity in a controlled manner.

### Core principles

1. **Start Simple**
   - Begin with basic requirements
   - Focus on core functionality
   - Establish clear baseline behavior

2. **Iterate Purposefully**
   - Add requirements systematically
   - Test each refinement
   - Document improvements

3. **Maintain Clarity**
   - Keep instructions clear
   - Avoid conflicting requirements
   - Document dependencies

### Implementation workflow

The progressive refinement process follows a structured workflow:

1. **Initial Prompt**
   - Define basic functionality
   - Set core parameters
   - Establish success criteria

2. **Analysis**
   - Evaluate output quality
   - Identify improvement areas
   - Document limitations

3. **Refinement**
   - Add specific requirements
   - Enhance constraints
   - Improve clarity

4. **Validation**
   - Test refined prompt
   - Verify improvements
   - Document changes

### Practical examples

Let's examine how progressive refinement works in practice:

<Tabs>
<TabItem value="technical_doc" label="Technical Documentation">

```markdown
# Initial Version
Generate API documentation for the authentication endpoint.

# Refinement 1
Generate API documentation for the authentication endpoint.
Include:
- Endpoint URL
- HTTP method
- Request format
- Response format

# Refinement 2
Generate API documentation for the authentication endpoint.
Include:
- Endpoint: POST /api/v1/auth
- Request format (JSON)
- Response format (JWT token)
- Error handling
- Rate limiting details
Target audience: Senior developers

# Final Version
Generate API documentation for the authentication endpoint.
Include:
- Endpoint: POST /api/v1/auth
- Request format (JSON):
  * email (required, valid format)
  * password (required, min 8 chars)
  * remember_me (optional boolean)
- Response format:
  * JWT token structure
  * Token expiration
  * Refresh mechanism
- Error scenarios:
  * Invalid credentials
  * Account locked
  * Rate limit exceeded
- Security considerations:
  * Rate limiting (100 requests/hour)
  * IP-based blocking
  * HTTPS required
Target audience: Senior developers
Include code examples in:
- cURL
- Python
- JavaScript
```

</TabItem>
<TabItem value="conversation_flow" label="Conversation Flow">

```xml
<!-- Initial Version -->
<prompt>
  Handle customer support inquiries about billing issues.
</prompt>

<!-- Refinement 1 -->
<prompt>
  Handle customer support inquiries about billing issues.
  Steps:
  1. Greet the customer
  2. Get account information
  3. Identify billing issue
  4. Provide solution
</prompt>

<!-- Refinement 2 -->
<prompt>
  Handle customer support inquiries about billing issues.
  Steps:
  1. Greet customer professionally
  2. Collect information:
     - Account number
     - Issue description
     - Last payment date
  3. Identify issue type:
     - Payment processing
     - Subscription status
     - Invoice discrepancy
  4. Provide appropriate solution
  5. Confirm resolution
</prompt>

<!-- Final Version -->
<prompt>
  Handle customer support inquiries about billing issues.
  
  Initial Greeting:
  - Professional and friendly tone
  - Identify yourself as billing support
  - Ask how you can help
  
  Information Collection:
  - Account number (required)
  - Issue description
  - Last payment date
  - Payment method used
  
  Issue Classification:
  - Payment processing errors
    * Failed transactions
    * Declined cards
    * Processing delays
  - Subscription issues
    * Status verification
    * Renewal problems
    * Plan changes
  - Invoice discrepancies
    * Wrong amount
    * Missing credits
    * Duplicate charges
    
  Resolution Process:
  - Verify issue details
  - Explain solution steps
  - Confirm customer understanding
  - Document resolution
  
  Closing:
  - Summarize actions taken
  - Provide reference number
  - Ask if further assistance needed
  
  Security Requirements:
  - Verify identity before sharing details
  - Never display full card numbers
  - Log all account changes
</prompt>
```

</TabItem>
</Tabs>

### Feedback integration

Effective progressive refinement relies on proper handling of feedback:

1. **Collect Feedback**
   - Monitor output quality
   - Track error patterns
   - Gather user responses

2. **Analyze Patterns**
   - Identify common issues
   - Detect edge cases
   - Note successful patterns

3. **Apply Improvements**
   - Update prompt structure
   - Enhance constraints
   - Add missing context

4. **Validate Changes**
   - Test refinements
   - Measure improvements
   - Document results

<Admonition type="tip">
When refining prompts, make one change at a time and test thoroughly before adding more complexity. This methodical approach helps isolate the impact of each change and ensures stable improvements.
</Admonition>

### Quality metrics

Track these key metrics during refinement:

1. **Accuracy**
   - Output correctness
   - Requirement adherence
   - Context relevance

2. **Consistency**
   - Response stability
   - Format compliance
   - Style uniformity

3. **Completeness**
   - Coverage of requirements
   - Handling of edge cases
   - Documentation quality

## Best practices for different tasks

Different types of tasks require different approaches to prompt engineering. Understanding these variations helps you craft more effective prompts for specific use cases. Let's explore the best practices for common task types.

## Analysis tasks

Analysis tasks require the AI to process and derive insights from structured data such as API responses, call logs, or communication metrics. In the context of SignalWire AI Agents, these tasks often involve analyzing communication patterns, user interactions, and system performance data to generate actionable insights.

### Structured workflow

Follow this workflow for effective analysis tasks:

1. **Data Collection**
   - Gather relevant information
   - Validate data completeness
   - Ensure proper formatting

2. **Analysis Framework**
   - Define analysis objectives
   - Set evaluation criteria
   - Establish metrics

3. **Insight Generation**
   - Process structured data
   - Identify patterns
   - Generate recommendations

### Implementation examples

Let's look at practical examples of analysis tasks in SignalWire contexts:

<Tabs>
<TabItem value="call_analysis" label="Call Analysis">

```xml
<analysis_task>
  <objective>
    Analyze customer support call patterns and quality
  </objective>

  <data_structure>
    <call_metrics>
      - Call duration
      - Response time
      - Resolution rate
      - Customer satisfaction
    </call_metrics>

    <interaction_data>
      - Conversation flow
      - Topic classification
      - Sentiment analysis
      - Resolution status
    </interaction_data>

    <quality_metrics>
      - Voice clarity
      - Response accuracy
      - Solution effectiveness
      - Follow-up needed
    </quality_metrics>
  </data_structure>

  <analysis_steps>
    <step_1>
      <action>Pattern Recognition</action>
      <focus>
        - Common issues
        - Peak call times
        - Resolution patterns
        - Escalation triggers
      </focus>
    </step_1>

    <step_2>
      <action>Quality Assessment</action>
      <focus>
        - Response accuracy
        - Solution effectiveness
        - Customer satisfaction
        - Agent performance
      </focus>
    </step_2>

    <step_3>
      <action>Improvement Identification</action>
      <focus>
        - Training needs
        - Process gaps
        - Resource allocation
        - Knowledge base updates
      </focus>
    </step_3>
  </analysis_steps>

  <output_format>
    <summary>
      - Key findings
      - Trend analysis
      - Recommendations
      - Action items
    </summary>
    
    <metrics>
      - Performance indicators
      - Quality scores
      - Improvement areas
      - Success rates
    </metrics>
  </output_format>
</analysis_task>
```

</TabItem>
<TabItem value="api_performance" label="API Performance">

```yaml
analysis_task:
  objective: "Analyze API performance and usage patterns"
  
  data_points:
    metrics:
      - response_time
      - error_rate
      - request_volume
      - endpoint_usage
    
    timeframe:
      - start_time
      - end_time
      - interval
    
    categories:
      - endpoint_type
      - user_segment
      - region
      - platform

  analysis_framework:
    performance:
      - latency_analysis:
          - average_response_time
          - percentile_distribution
          - peak_latency_periods
      
      - reliability_metrics:
          - error_frequency
          - failure_patterns
          - recovery_time
      
      - capacity_utilization:
          - peak_usage_periods
          - resource_consumption
          - scaling_events

    patterns:
      - usage_trends:
          - daily_patterns
          - weekly_cycles
          - monthly_growth
      
      - user_behavior:
          - common_sequences
          - feature_adoption
          - integration_patterns
      
      - error_analysis:
          - common_failures
          - error_correlations
          - impact_assessment

  output_requirements:
    format:
      - structured_report
      - visual_graphs
      - trend_analysis
    
    recommendations:
      - performance_optimization
      - resource_allocation
      - error_prevention
    
    action_items:
      - immediate_actions
      - short_term_improvements
      - long_term_strategy
```

</TabItem>
</Tabs>

### Handling unexpected data

When dealing with analysis tasks, it's crucial to handle unexpected or incomplete data effectively:

1. **Data Validation**
   ```xml
   <validation_rules>
     <required_fields>
       - timestamp
       - event_type
       - session_id
     </required_fields>
     
     <data_types>
       - numeric: metrics, durations
       - string: identifiers, status
       - boolean: flags, states
     </data_types>
     
     <range_checks>
       - duration: > 0
       - quality_score: 0-100
       - error_count: >= 0
     </range_checks>
   </validation_rules>
   ```

2. **Missing Data Strategy**
   ```xml
   <missing_data_handling>
     <categorization>
       - Critical: Required for analysis
       - Optional: Enhances analysis
       - Supplementary: Nice to have
     </categorization>
     
     <actions>
       - Critical: Stop and report
       - Optional: Use defaults
       - Supplementary: Skip
     </actions>
     
     <documentation>
       - Log missing fields
       - Record impact
       - Note assumptions
     </documentation>
   </missing_data_handling>
   ```

3. **Error Recovery**
   ```xml
   <error_handling>
     <detection>
       - Validate data types
       - Check ranges
       - Verify relationships
     </detection>
     
     <response>
       - Log errors
       - Apply corrections
       - Flag for review
     </response>
     
     <reporting>
       - Error summary
       - Impact assessment
       - Resolution status
     </reporting>
   </error_handling>
   ```

### Best practices

1. **Data Preparation**
   - Validate input format
   - Clean and normalize data
   - Document assumptions

2. **Analysis Process**
   - Follow structured approach
   - Document methodology
   - Validate results

3. **Output Generation**
   - Provide clear insights
   - Include supporting data
   - Recommend actions

<Admonition type="tip">
When analyzing communication data, focus on patterns that indicate user experience issues or system inefficiencies. This helps identify opportunities for improving the SignalWire service quality.
</Admonition>

## Generation tasks

Generation tasks involve creating new content, from simple responses to complex structured outputs. In the SignalWire context, these tasks often involve generating voice responses, chat messages, documentation, or configuration files. Success requires clear guidelines, consistent formatting, and robust quality control.

### Task categories

1. **Voice Interaction**
   - Customer greetings
   - Response generation
   - Error handling
   - Call flow management

2. **Documentation**
   - API guides
   - Integration tutorials
   - Troubleshooting guides
   - Release notes

3. **Configuration**
   - System settings
   - Integration parameters
   - Call routing rules
   - Security policies

### Implementation guidelines

Let's examine practical examples for different types of generation tasks:

<Tabs>
<TabItem value="voice_interaction" label="Voice Interaction">

```xml
<voice_interaction>
  <context>
    Customer support call handling for SignalWire services
  </context>

  <interaction_flow>
    <greeting>
      <requirements>
        - Professional tone
        - Company identification
        - Purpose statement
        - Time-appropriate greeting
      </requirements>
      
      <example>
        "Good [morning/afternoon/evening], thank you for calling SignalWire support. 
        My name is [Agent Name], how can I assist you today?"
      </example>
    </greeting>

    <issue_handling>
      <steps>
        - Listen to customer issue
        - Acknowledge concern
        - Ask clarifying questions
        - Propose solution
        - Confirm understanding
      </steps>
      
      <response_guidelines>
        - Clear articulation
        - Appropriate pace
        - Professional vocabulary
        - Technical accuracy
      </response_guidelines>
    </issue_handling>

    <resolution>
      <components>
        - Summarize actions
        - Confirm resolution
        - Offer additional help
        - Thank customer
      </components>
      
      <quality_checks>
        - Solution effectiveness
        - Customer satisfaction
        - Documentation complete
        - Follow-up needed
      </quality_checks>
    </resolution>
  </interaction_flow>

  <error_handling>
    <scenarios>
      - Connection issues
      - System limitations
      - Service outages
      - Authentication failures
    </scenarios>
    
    <responses>
      - Clear explanation
      - Alternative solutions
      - Escalation paths
      - Status updates
    </responses>
  </error_handling>
</voice_interaction>
```

</TabItem>
<TabItem value="api_documentation" label="API Documentation">

```yaml
documentation_task:
  context: "SignalWire REST API Integration Guide"
  
  structure:
    overview:
      - service_description
      - key_features
      - prerequisites
      - authentication
    
    endpoints:
      - base_url
      - available_methods
      - request_format
      - response_format
    
    authentication:
      - api_keys
      - token_management
      - security_best_practices
    
    examples:
      - basic_usage
      - advanced_scenarios
      - error_handling
      - rate_limiting

  content_requirements:
    technical_depth:
      - beginner_friendly
      - intermediate_concepts
      - advanced_usage
    
    code_samples:
      languages:
        - Python
        - JavaScript
        - Ruby
        - PHP
      
      components:
        - authentication
        - request_construction
        - response_handling
        - error_management
    
    best_practices:
      - security_guidelines
      - performance_optimization
      - error_handling
      - rate_limiting

  quality_controls:
    accuracy:
      - technical_correctness
      - code_validity
      - current_api_version
      - parameter_accuracy
    
    completeness:
      - all_endpoints_covered
      - error_scenarios_documented
      - examples_provided
      - edge_cases_addressed
    
    usability:
      - clear_structure
      - logical_flow
      - searchable_content
      - consistent_formatting
```

</TabItem>
</Tabs>

### Quality control measures

Implement these quality control measures for generation tasks:

1. **Content Validation**
   ```xml
   <validation_framework>
     <technical_accuracy>
       - Verify API endpoints
       - Test code samples
       - Check parameter types
       - Validate responses
     </technical_accuracy>
     
     <content_quality>
       - Grammar and spelling
       - Technical terminology
       - Formatting consistency
       - Link validation
     </content_quality>
     
     <user_experience>
       - Navigation flow
       - Information hierarchy
       - Search functionality
       - Mobile responsiveness
     </user_experience>
   </validation_framework>
   ```

2. **Style Enforcement**
   ```xml
   <style_guidelines>
     <voice_and_tone>
       - Professional but approachable
       - Technical when needed
       - Clear and concise
       - Consistent terminology
     </voice_and_tone>
     
     <formatting_rules>
       - Heading hierarchy
       - Code block styling
       - List formatting
       - Table structure
     </formatting_rules>
     
     <naming_conventions>
       - Variable names
       - Function names
       - File paths
       - Configuration keys
     </naming_conventions>
   </style_guidelines>
   ```

3. **Technical Verification**
   ```xml
   <technical_checks>
     <code_validation>
       - Syntax checking
       - Runtime testing
       - Security scanning
       - Performance testing
     </code_validation>
     
     <integration_testing>
       - API compatibility
       - Version checking
       - Dependency validation
       - Environment testing
     </integration_testing>
     
     <security_review>
       - Authentication flow
       - Data protection
       - Access control
       - Compliance check
     </security_review>
   </technical_checks>
   ```

### Best practices

1. **Planning and Structure**
   - Define clear objectives
   - Outline content structure
   - Identify dependencies
   - Set quality criteria

2. **Content Development**
   - Follow style guidelines
   - Maintain consistency
   - Include examples
   - Document edge cases

3. **Quality Assurance**
   - Technical review
   - Content validation
   - User testing
   - Performance check

<Admonition type="tip">
When generating voice interactions or documentation, always consider the user's technical expertise level and provide appropriate context and examples for their skill level.
</Admonition>

<Admonition type="warning">
Avoid generating sensitive information or security-critical code without proper review and validation. Always verify generated content for security implications before implementation.
</Admonition>
