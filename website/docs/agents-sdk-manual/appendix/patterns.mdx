---
sidebar_position: 2
title: "Patterns"
slug: /patterns
---

## Design Patterns

> **Summary**: Common architectural patterns and solutions for building SignalWire voice AI agents.

### Overview

| Pattern | Description |
|---------|-------------|
| Decorator Pattern | Add functions with `@agent.tool` decorator |
| Class-Based Agent | Subclass AgentBase for reusable agents |
| Multi-Agent Router | Route calls to specialized agents |
| State Machine | Use contexts for multi-step workflows |
| DataMap Integration | Serverless API integration |
| Skill Composition | Combine built-in skills |
| Dynamic Configuration | Runtime agent customization |

### Decorator Pattern

The simplest way to create an agent with functions:

```python
from signalwire_agents import AgentBase
from signalwire_agents.core.function_result import SwaigFunctionResult

agent = AgentBase(name="helper", route="/helper")
agent.prompt_add_section("Role", "You help users with account information.")
agent.add_language("English", "en-US", "rime.spore")

@agent.tool(description="Look up account by ID")
def lookup_account(account_id: str) -> SwaigFunctionResult:
    # Lookup logic here
    return SwaigFunctionResult(f"Account {account_id} found.")

@agent.tool(description="Update account status")
def update_status(account_id: str, status: str) -> SwaigFunctionResult:
    # Update logic here
    return SwaigFunctionResult(f"Account {account_id} updated to {status}.")

if __name__ == "__main__":
    agent.run()
```

### Class-Based Agent Pattern

For reusable, shareable agent definitions:

```python
from signalwire_agents import AgentBase
from signalwire_agents.core.function_result import SwaigFunctionResult

class SupportAgent(AgentBase):
    def __init__(self):
        super().__init__(name="support", route="/support")
        self.prompt_add_section("Role", "You are a technical support agent.")
        self.prompt_add_section("Guidelines", """
        - Be patient and helpful
        - Gather issue details before troubleshooting
        - Escalate complex issues to human support
        """)
        self.add_language("English", "en-US", "rime.spore")
        self.add_skill("datetime")

    @AgentBase.tool(description="Create support ticket")
    def create_ticket(self, issue: str, priority: str = "normal") -> SwaigFunctionResult:
        ticket_id = f"TKT-{id(self) % 10000:04d}"
        return SwaigFunctionResult(f"Created ticket {ticket_id} for: {issue}")

    @AgentBase.tool(description="Transfer to human support")
    def transfer_to_human(self) -> SwaigFunctionResult:
        return (
            SwaigFunctionResult("Connecting you to a support representative.")
            .connect("+15551234567", final=True)
        )

if __name__ == "__main__":
    agent = SupportAgent()
    agent.run()
```

### Multi-Agent Router Pattern

Route calls to specialized agents based on intent:

```python
from signalwire_agents import AgentBase, AgentServer
from signalwire_agents.core.function_result import SwaigFunctionResult


class RouterAgent(AgentBase):
    def __init__(self, base_url: str):
        super().__init__(name="router", route="/")
        self.base_url = base_url
        self.prompt_add_section("Role", """
        You are a receptionist. Determine what the caller needs and
        route them to the appropriate department.
        """)
        self.prompt_add_section("Departments", """
        - Sales: Product inquiries, pricing, purchases
        - Support: Technical help, troubleshooting
        - Billing: Payments, invoices, account issues
        """)
        self.add_language("English", "en-US", "rime.spore")

    @AgentBase.tool(description="Transfer to sales department")
    def transfer_sales(self) -> SwaigFunctionResult:
        return (
            SwaigFunctionResult("Transferring to sales.")
            .connect(f"{self.base_url}/sales", final=True)
        )

    @AgentBase.tool(description="Transfer to support department")
    def transfer_support(self) -> SwaigFunctionResult:
        return (
            SwaigFunctionResult("Transferring to support.")
            .connect(f"{self.base_url}/support", final=True)
        )


if __name__ == "__main__":
    server = AgentServer(host="0.0.0.0", port=8080)
    server.register(RouterAgent("https://agent.example.com"))
    server.run()
```

### State Machine Pattern (Contexts)

Use contexts for structured multi-step workflows:

```python
from signalwire_agents import AgentBase
from signalwire_agents.core.contexts import ContextBuilder
from signalwire_agents.core.function_result import SwaigFunctionResult


class VerificationAgent(AgentBase):
    def __init__(self):
        super().__init__(name="verify", route="/verify")
        self.add_language("English", "en-US", "rime.spore")
        self._setup_contexts()

    def _setup_contexts(self):
        ctx = ContextBuilder("verification")

        ctx.add_step(
            "greeting",
            "Welcome the caller and ask for their account number.",
            functions=["verify_account"],
            valid_steps=["collect_info"]
        )

        ctx.add_step(
            "collect_info",
            "Verify the caller's identity by asking security questions.",
            functions=["verify_security"],
            valid_steps=["authenticated", "failed"]
        )

        ctx.add_step(
            "authenticated",
            "The caller is verified. Ask how you can help them today.",
            functions=["check_balance", "transfer_funds", "end_call"],
            valid_steps=["end"]
        )

        self.add_context(ctx.build(), default=True)

    @AgentBase.tool(description="Verify account number")
    def verify_account(self, account_number: str) -> SwaigFunctionResult:
        return SwaigFunctionResult(f"Account {account_number} found.")

    @AgentBase.tool(description="Check account balance")
    def check_balance(self, account_id: str) -> SwaigFunctionResult:
        return SwaigFunctionResult("Current balance is $1,234.56")
```

### DataMap Integration Pattern

Use DataMap for serverless API integration:

```python
from signalwire_agents import AgentBase
from signalwire_agents.core.data_map import DataMap

agent = AgentBase(name="weather", route="/weather")
agent.prompt_add_section("Role", "You provide weather information.")
agent.add_language("English", "en-US", "rime.spore")

## Define DataMap tool
weather_map = DataMap(
    name="get_weather",
    description="Get current weather for a city"
)

weather_map.add_parameter("city", "string", "City name", required=True)

weather_map.add_webhook(
    url="https://api.weather.com/v1/current?q=${enc:args.city}&key=API_KEY",
    method="GET",
    output_map={
        "response": "Weather in ${args.city}: ${response.temp}F, ${response.condition}"
    },
    error_map={
        "response": "Could not retrieve weather for ${args.city}"
    }
)

agent.add_data_map_tool(weather_map)

if __name__ == "__main__":
    agent.run()
```

### Skill Composition Pattern

Combine multiple skills for comprehensive functionality:

```python
from signalwire_agents import AgentBase
from signalwire_agents.core.function_result import SwaigFunctionResult

agent = AgentBase(name="assistant", route="/assistant")
agent.prompt_add_section("Role", """
You are a comprehensive assistant that can:

- Tell the current time and date
- Search our knowledge base
- Look up weather information
""")
agent.add_language("English", "en-US", "rime.spore")

## Add built-in skills
agent.add_skill("datetime")
agent.add_skill("native_vector_search", {
    "index_path": "./knowledge.swsearch",
    "tool_name": "search_docs",
    "tool_description": "Search documentation"
})

## Add custom function alongside skills
@agent.tool(description="Escalate to human agent")
def escalate(reason: str) -> SwaigFunctionResult:
    return (
        SwaigFunctionResult(f"Escalating: {reason}")
        .connect("+15551234567", final=True)
    )

if __name__ == "__main__":
    agent.run()
```

### Dynamic Configuration Pattern

Configure agents dynamically at runtime:

```python
from signalwire_agents import AgentBase
from signalwire_agents.core.function_result import SwaigFunctionResult
from typing import Dict, Any


class DynamicAgent(AgentBase):
    def __init__(self):
        super().__init__(name="dynamic", route="/dynamic")
        self.add_language("English", "en-US", "rime.spore")
        self.set_dynamic_config_callback(self.configure_from_call)

    def configure_from_call(
        self,
        query_params: Dict[str, Any],
        body_params: Dict[str, Any],
        headers: Dict[str, str],
        agent: 'AgentBase'
    ) -> None:
        # Get caller's phone number from body
        caller = body_params.get("call", {}).get("from", "")

        # Customize prompt based on caller
        if caller.startswith("+1555"):
            agent.prompt_add_section("Role", "You are a VIP support agent.")
        else:
            agent.prompt_add_section("Role", "You are a standard support agent.")

        # Add caller info to global data
        agent.set_global_data({"caller_number": caller})


if __name__ == "__main__":
    agent = DynamicAgent()
    agent.run()
```

### Pattern Selection Guide

| Scenario | Recommended Pattern |
|----------|---------------------|
| Quick prototype or simple agent | Decorator Pattern |
| Reusable agent for sharing | Class-Based Agent |
| Multiple specialized agents | Multi-Agent Router |
| Step-by-step workflows | State Machine (Contexts) |
| External API integration | DataMap Integration |
| Feature-rich agent | Skill Composition |
| Per-call customization | Dynamic Configuration |


