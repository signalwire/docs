---
sidebar_position: 5
title: "Native Functions"
slug: /swaig-functions/native-functions
---

## Native Functions

> **Summary**: Native functions are built-in SignalWire capabilities that can be enabled without writing code. They provide common operations like web search and debugging.

### What Are Native Functions?

Native functions run directly on SignalWire's platform. Enable them to give the AI access to built-in capabilities without creating handlers.

| Handler Function | Native Function |
|------------------|-----------------|
| You define handler | SignalWire provides |
| Runs on your server | Runs on SignalWire |
| Custom logic | Pre-built behavior |

**Available Native Functions:**

- `web_search` - Search the web
- `debug` - Debug mode for testing

### Enabling Native Functions

Enable native functions in the constructor:

```python
from signalwire_agents import AgentBase


class MyAgent(AgentBase):
    def __init__(self):
        super().__init__(
            name="my-agent",
            native_functions=["web_search"]  # Enable web search
        )
        self.add_language("English", "en-US", "rime.spore")
```

### Web Search Function

Enable web search to let the AI look up information:

```python
class ResearchAgent(AgentBase):
    def __init__(self):
        super().__init__(
            name="research-agent",
            native_functions=["web_search"]
        )
        self.add_language("English", "en-US", "rime.spore")

        self.prompt_add_section(
            "Role",
            "You are a research assistant. Search the web to answer questions."
        )
```

The AI can now search the web to find answers to caller questions.

### Debug Function

Enable debug mode for development and testing:

```python
class DebugAgent(AgentBase):
    def __init__(self):
        super().__init__(
            name="debug-agent",
            native_functions=["debug"]
        )
        self.add_language("English", "en-US", "rime.spore")
```

The debug function provides diagnostic information during testing.

### Call Transfers

For call transfers, use `SwaigFunctionResult.connect()` in a custom handler function - there is no native transfer function:

```python
from signalwire_agents import AgentBase, SwaigFunctionResult


class TransferAgent(AgentBase):
    DEPARTMENTS = {
        "sales": "+15551111111",
        "support": "+15552222222",
        "billing": "+15553333333"
    }

    def __init__(self):
        super().__init__(name="transfer-agent")
        self.add_language("English", "en-US", "rime.spore")

        self.prompt_add_section(
            "Role",
            "You are a receptionist. Transfer callers to the appropriate department."
        )

        self.define_tool(
            name="transfer_call",
            description="Transfer the call to a department",
            parameters={
                "type": "object",
                "properties": {
                    "department": {
                        "type": "string",
                        "description": "Department to transfer to",
                        "enum": ["sales", "support", "billing"]
                    }
                },
                "required": ["department"]
            },
            handler=self.transfer_call
        )

    def transfer_call(self, args, raw_data):
        department = args.get("department")
        number = self.DEPARTMENTS.get(department)

        if not number:
            return SwaigFunctionResult("Invalid department")

        return (
            SwaigFunctionResult(f"Transferring you to {department}")
            .connect(number, final=True)
        )
```

### Combining Native and Custom Functions

Use native functions alongside your custom handlers:

```python
from signalwire_agents import AgentBase, SwaigFunctionResult


class HybridAgent(AgentBase):
    def __init__(self):
        super().__init__(
            name="hybrid-agent",
            native_functions=["web_search"]  # Native
        )
        self.add_language("English", "en-US", "rime.spore")

        # Custom function alongside native ones
        self.define_tool(
            name="check_account",
            description="Look up customer account information",
            parameters={
                "type": "object",
                "properties": {
                    "account_id": {
                        "type": "string",
                        "description": "Account ID"
                    }
                },
                "required": ["account_id"]
            },
            handler=self.check_account
        )

        self.prompt_add_section(
            "Role",
            "You are a customer service agent. "
            "You can check accounts and search the web for information."
        )

    def check_account(self, args, raw_data):
        account_id = args.get("account_id")
        return SwaigFunctionResult(f"Account {account_id} is active")
```

### When to Use Native vs Custom Functions

| Scenario | Recommendation |
|----------|----------------|
| Web search capability | Use `web_search` native function |
| Development testing | Use `debug` native function |
| Transfer to phone number | Use SwaigFunctionResult.connect() in custom handler |
| Transfer to SIP address | Use SwaigFunctionResult.connect() in custom handler |
| Custom business logic | Use define_tool() with handler |
| Database lookups | Use define_tool() with handler |

### Native Functions Reference

| Function | Description | Use Case |
|----------|-------------|----------|
| `web_search` | Search the web | Answer general questions |
| `debug` | Debug information | Development/testing |

### Next Steps

You've now learned all about SWAIG functions. Next, explore Skills to add pre-built capabilities to your agents.


