---
slug: /swml/reference/expressions
title: Expressions
tags: ['swml']
x-custom:
  tags:
    - sdk:swml
    - product:voice
description: Complete technical reference for JavaScript expressions and data access patterns in SWML.
---

# SWML Expressions

<Subtitle>Complete reference for JavaScript expressions and data manipulation in SWML</Subtitle>

SWML variables support JavaScript expressions for dynamic value construction, data manipulation, and conditional logic. This page is the authoritative technical reference for using expressions within SWML variables.

For information about variable scopes and the Call Object, see the [Variables Reference](/swml/reference/variables). For template transformation functions, see the [Template Functions Reference](/swml/reference/template-functions).

## Expression Syntax

Expressions in SWML use the `${...}` syntax and support JavaScript:

```yaml
# Simple variable reference
- play:
    url: 'say: ${call.from}'

# JavaScript expression
- play:
    url: 'say: ${call.from.substring(0, 3)}'

# Complex expression
- set:
    total: '${(params.price * params.quantity).toFixed(2)}'
```

## Accessing Variable Data

### Simple Property Access

Access variables directly by name:

```yaml
- set:
    name: Alice
- play:
    url: 'say: Hello ${name}'
```

### Nested Object Access

Access nested properties using dot notation:

```yaml
- set:
    user:
      name: Alice
      phone: '555-1234'
      address:
        city: Seattle
- play:
    url: 'say: ${user.name} lives in ${user.address.city}'
```

### Array Access

Access array elements using bracket notation:

```yaml
- set:
    items:
      - apple
      - banana
      - cherry
- play:
    url: 'say: First item is ${items[0]}'

# Access nested arrays
- return:
    - a: 1
      b: 2
    - a: 3
      b: 4
- play:
    url: 'say: returned ${return_value[0].a}'
```

### Dynamic Property Access

Use nested variable substitution for dynamic property names:

```yaml
# In SWAIG data_map context
data_map:
  expressions:
    - pattern: ".*"
      string: '${meta_data.table.${lc:args.target}}'
```

## JavaScript Expressions in Variables

Variables can include JavaScript expressions for dynamic value construction:

### String Manipulation

```yaml
# Split and join
- play:
    url: "say: ${call.from.split('').join(' ')}"
# "5551234" becomes "5 5 5 1 2 3 4"

# String methods
- play:
    url: "say: ${call.type.toUpperCase()}"
# "phone" becomes "PHONE"

- play:
    url: "say: ${call.from.substring(0, 3)}"
# Extract first 3 digits

# String concatenation
- set:
    full_name: '${user.first_name + " " + user.last_name}'

# Template literals (when supported)
- set:
    greeting: '${`Hello, ${user.name}!`}'
```

### Arithmetic Operations

```yaml
# Addition
- return: '${parseInt(params.a) + parseInt(params.b)}'

# Multiplication
- set:
    total: '${params.price * params.quantity}'

# Complex expressions
- set:
    discount: '${(params.price * 0.9).toFixed(2)}'

# Division and rounding
- set:
    average: '${Math.round(total / count)}'

# Modulo operator
- set:
    is_even: '${counter % 2 == 0}'
```

### Conditional Expressions

```yaml
# Ternary operator
- set:
    greeting: '${call.direction == "inbound" ? "Welcome" : "Calling"}'

# Comparison
- set:
    is_special: '${call.from.startsWith("555")}'

# Complex conditional
- set:
    status: '${call.type == "phone" && call.direction == "inbound" ? "valid" : "invalid"}'

# Nullish coalescing (when supported)
- set:
    display_name: '${user.name ?? "Guest"}'
```

### Array Methods

```yaml
# Array length
- play:
    url: 'say: You have ${items.length} items'

# Array join
- play:
    url: 'say: Items are ${items.join(", ")}'

# Array includes
- set:
    has_apple: '${items.includes("apple")}'

# Array filtering/mapping (when supported)
- set:
    uppercase_items: '${items.map(x => x.toUpperCase())}'

# Array access with expressions
- set:
    last_item: '${items[items.length - 1]}'
```

### Object Methods

```yaml
# Object.keys
- set:
    field_names: '${Object.keys(user).join(", ")}'

# Object.values
- set:
    field_values: '${Object.values(user)}'

# Check property existence
- set:
    has_email: '${user.hasOwnProperty("email")}'
```

### Type Conversion

```yaml
# String to number
- set:
    num: '${parseInt(prompt_value)}'
    float_num: '${parseFloat(params.price)}'

# Number to string
- set:
    count_str: '${counter.toString()}'

# Boolean conversion
- set:
    is_true: '${Boolean(value)}'
```

### Math Operations

```yaml
# Math functions
- set:
    max_value: '${Math.max(a, b, c)}'
    min_value: '${Math.min(a, b, c)}'
    absolute: '${Math.abs(difference)}'
    random: '${Math.random()}'

# Rounding
- set:
    rounded: '${Math.round(value)}'
    ceiling: '${Math.ceil(value)}'
    floor: '${Math.floor(value)}'
```

## Using Expressions in Conditional Logic

Expressions are commonly used in [`cond`](/swml/methods/cond) statements for flow control:

```yaml
- cond:
    - when: call.type.toLowerCase() == 'sip'
      then:
        - play:
            url: "say: You're calling from SIP."
    - when: call.direction == 'inbound'
      then:
        - play:
            url: "say: This is an inbound call."
    - when: parseInt(prompt_value) > 5
      then:
        - play:
            url: "say: Number is greater than 5."
```

## Complex Expression Examples

### Formatting Phone Numbers

```yaml
- set:
    formatted_phone: '${call.from.replace(/(\d{3})(\d{3})(\d{4})/, "($1) $2-$3")}'
# "5551234567" becomes "(555) 123-4567"
```

### Date Calculations

```yaml
# Calculate age from year
- set:
    age: '${new Date().getFullYear() - parseInt(params.birth_year)}'

# Time since epoch
- set:
    timestamp: '${Date.now()}'
```

### String Validation

```yaml
# Email validation (basic)
- set:
    is_valid_email: '${params.email.includes("@") && params.email.includes(".")}'

# Length check
- set:
    is_valid_code: '${params.code.length == 6 && /^\d+$/.test(params.code)}'
```

### Chaining Methods

```yaml
# Multiple operations
- set:
    cleaned_input: '${prompt_value.trim().toLowerCase().replace(/\s+/g, "_")}'

# Complex transformation
- set:
    display_list: '${items.filter(x => x).map(x => x.toUpperCase()).join(", ")}'
```

## Expression Best Practices

### Keep Expressions Readable

Break complex logic into multiple steps:

```yaml
# ❌ Hard to read
- set:
    result: '${items.filter(x => x.price > 10).map(x => x.name).slice(0, 5).join(", ")}'

# ✅ Better
- set:
    expensive_items: '${items.filter(x => x.price > 10)}'
- set:
    item_names: '${expensive_items.map(x => x.name)}'
- set:
    top_five: '${item_names.slice(0, 5).join(", ")}'
```

### Handle Undefined Values

Use defensive checks to prevent errors:

```yaml
# Check for existence
- set:
    safe_value: '${user && user.name ? user.name : "Unknown"}'

# Use optional chaining (when supported)
- set:
    safe_value: '${user?.name ?? "Unknown"}'
```

### Validate Input Types

Convert and validate user input:

```yaml
# Ensure numeric input
- set:
    quantity: '${isNaN(parseInt(prompt_value)) ? 1 : parseInt(prompt_value)}'

# Validate string length
- set:
    valid_code: '${params.code && params.code.length == 6 ? params.code : "000000"}'
```

## Expression Limitations

### Not All JavaScript Features Are Supported

SWML expressions support a subset of JavaScript:

- ✅ Basic operators, string methods, array methods, Math functions
- ✅ Ternary operators, logical operators
- ✅ parseInt, parseFloat, type conversions
- ❌ Async/await, promises
- ❌ Function declarations
- ❌ Variable declarations (let, const, var)

### Escaping Special Characters

When using special characters in expressions, proper escaping may be required:

```yaml
# Use single quotes inside double quotes
- set:
    message: "${call.from.replace('5', 'X')}"

# Or use double quotes inside single quotes
- set:
    message: '${call.from.replace("5", "X")}'
```

## See Also

- **[Variables Reference](/swml/reference/variables)**: Variable scopes and the Call Object
- **[Template Functions Reference](/swml/reference/template-functions)**: Built-in transformation functions
- **[`cond` method](/swml/methods/cond)**: Conditional logic using expressions
- **[`set` method](/swml/methods/set)**: Store expression results in variables
